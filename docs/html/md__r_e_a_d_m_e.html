<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SerialChecker: SerialChecker</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SerialChecker
   </div>
   <div id="projectbrief">Arduino serial checker that handles ACK, NAK and checksums</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="class_serial_checker.html" title="SerialChecker is an Arduino based class for the easy handling of serial messages. SerialChecker can b...">SerialChecker</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="class_serial_checker.html" title="SerialChecker is an Arduino based class for the easy handling of serial messages. SerialChecker can b...">SerialChecker</a> is an arduino based class for the easy handling of serial messages between an Arduino and another device such as a PC or another arduino. At the moment, it only works with the hardware serial port on an arduino such as Serial. That is, just Serial on an Arduino Uno and Serial1, Serial2 or Serial3 on an Arduino Mega etc.</p>
<h3>Features</h3>
<ol type="1">
<li>Checks received message length is between a minimum and maximum number of chars</li>
<li>Non-blocking checking code. The arduino can be busy doing other things rather than waiting for a message to finish being sent.</li>
<li>Choose the end of message char. Default is '<br />
'.</li>
<li>Choose optional start of message char such as '$'. Not required by default.</li>
<li>Send acknowledge and not acknowledge (ACK and NAK) messages. NAK messages can be automatically sent if the received message does not meet validity requirements.</li>
<li>Can handle checking for valid checksums at end of received messages. Not required by default. The checksum function can be used to calculated a checksum for outgoing messages as well.</li>
<li>Can check for the presence of char arrays in the incoming message making it simple for the user to decide how to handle the message. For example, check for presence of "ID" to know the user wants to know which arduino is connected to COM3...</li>
<li>Can convert chosen parts of the message to floats and both signed and unsigned 8, 16 and 32 bit integers.</li>
</ol>
<h3>Typical usage</h3>
<p>This code was written for use in a research laboratory where most of the hardware is controlled by arduino compatible microcontroller boards. Most of the hardware, such as power supplies and detectors are made inhouse. Arduinos are used for things like setting voltages and temperatures, getting readings and controlling stepper motors. Serial messages are transferred between the arduinos and monitoring and controlling computers, mostly running LabVIEW control systems.</p>
<p>Asynchronous serial communications are susceptible to noise or timing issues which can result in garbled messages being received or messages missed entirely. In these uses, especially when setting voltages or currents on sensitive equipment, a garbled serial message could cause catastrophic damage. For example, accidentally setting a high voltage on a detector power supply would 'spike' the device with enough charge to destroy it.</p>
<p>If a message is sent to the arduino along with a checksum, errors are significantly reduced. The arduino can send back NAK (not acknowledged) chars in the case that a valid message was not received, thereby alerting the sender to resend etc. Sending ACK messages lets the sender know the message was successfully received as well. This serial library handles these cases, provides an easy way to recognise commands and interprete ascii messages in to floats and ints.</p>
<h3>Installation</h3>
<p>For now, just place <a class="el" href="_serial_checker_8h_source.html">SerialChecker.h</a> and SerialChecker.cpp in the same folder as the arduino .ino file and type <code>#include "SerialChecker.h"</code> at the top of the file.</p>
<p>Documentation is available at: <a href="https://matthewaharvey.github.io/SerialChecker/html/class_serial_checker.html">https://matthewaharvey.github.io/SerialChecker/html/class_serial_checker.html</a></p>
<h3>Examples</h3>
<p>This first example starts a <a class="el" href="class_serial_checker.html" title="SerialChecker is an Arduino based class for the easy handling of serial messages. SerialChecker can b...">SerialChecker</a> instance (<code>sc</code>) and uses it to control the brightness of the builtin LED on pin 13's PWM mode. In the loop, <code>sc.check()</code> returns the message length if a message is received.</p>
<p><code>sc.contains(char* command)</code> is then used to check if <code>command</code> string is present at the start of the received message. If the start of the message is "ON", pin 13's LED is switched on. If the start of the message is "OFF", pin 13's LED is switched off.</p>
<p>If the first char is 'B', then <code>sc.int8()</code> is used to convert the rest of the message to a uint8_t value that is then used to set the brightness of the LED on pin 13.</p>
<p><code>sc.int8()</code> was not given an argument so it looks through the received message until a minus sign or an integer number is found. The function then converts the rest of the message into an int8. This works for both signed and unsigned values as long as the container is of the correct type. In this case, <code>uint8_t brightness</code> is used.</p>
<div class="fragment"><div class="line">#include &quot;SerialChecker.h&quot;</div><div class="line"></div><div class="line">SerialChecker sc;</div><div class="line"></div><div class="line">void setup(){</div><div class="line">    sc.init();</div><div class="line">    Serial.println(&quot;Connected to SerialCheckerExample.ino&quot;);</div><div class="line">    pinMode(13, OUTPUT);</div><div class="line">}</div><div class="line"></div><div class="line">void loop(){</div><div class="line">    if(sc.check()){</div><div class="line">        if(sc.contains(&quot;ON&quot;)){</div><div class="line">            analogWrite(13, 255);</div><div class="line">        }</div><div class="line">        else if(sc.contains(&quot;OFF&quot;)){}</div><div class="line">            analogWrite(13, 0);</div><div class="line">        }</div><div class="line">        else if(sc.contains(&quot;B&quot;)){}</div><div class="line">            uint8_t brightness = sc.int8();</div><div class="line">            analogWrite(13, brightness);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    // Do other stuff...</div><div class="line">}</div></div><!-- fragment --><h3>Checksum algorithm</h3>
<p>A standard 8 bit checksum sums all of the chars in a message in to a byte. If the sum is greater than 255 (2^8 - 1), it just wraps around. The checksum is then the negative of this number. In processors that use <a href="https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html">two's complement</a> signed numbers (the way to represent positive and negative integers), this is done by flipping all the bits and adding 1. Or you can just write <code>checksum = -checksum</code> and have the compiler do it for you.</p>
<p>So to send a message with a checksum, compute the checksum for the message to be sent, append it to the message char array and send it. To check if a received message is valid, sum all of the chars in the received message. If the value is 0, then the message passed the checksum. Why does this work? The value of the checksum is the negative of the sum value of the rest of the message.</p>
<p>This technique works well for clocked serial messages but not so well with ascii serial messages that are typically used by arduinos and lab equipment. In these cases, it is common for messages to end with a newline '<br />
' or other chosen char. A char is a byte, i.e., number between 0 and 255, and these numbers are mapped to a long established <a href="https://www.rapidtables.com/code/text/ascii-table.html">ascii table</a>. In this mapping, the newline '<br />
' char is the integer number 10, 0x0A in hexadecimal and 0b00001010 in a binary byte. If the simple checksum algoritm described above is used, then there is nothing stopping it producing the '<br />
' char as the computed checksum. When the arduino receives this, it would think that the message has ended and that the previously received char was the checksum. This would prevent the message being received successfully.</p>
<p>A simple way around this is to restrict the range of char values that the checksum calculation can produce. In <a class="el" href="class_serial_checker.html" title="SerialChecker is an Arduino based class for the easy handling of serial messages. SerialChecker can b...">SerialChecker</a>, there are two implemented algorithms to do this:</p><ol type="1">
<li>The first is based on that used by Spellman MPS high voltage power supplies. See the<a href="https://www.spellmanhv.com/-/media/en/Products/MPS-Digital-Interface.pdf">Spellman MPS Digital Interface manual</a> for details. This algorithm produces 64 unique checksum chars and none of these overlap with '<br />
' or the start and end chars used by those power supplies to signify the start and end of their serial messages.</li>
<li>The second method sums all the message chars in to a byte before clearing the most significant bit. This has the effect of limiting the sum to between 0 and 127. This is then further restricted to the range of 33 to 126. This range is the entire range of chars from '!' to '~' that is printable by the arduino IDE. This range is chosen to aid debugging and the manual entry of checksums when communicating with the arduino via the arduino IDE's limited serial monitor.</li>
</ol>
<p>When either of these algorithms are used, the sending device must append the calculated checksum. The receiving device splits the last received char (the checksum) off from the message, recalculates the checksum from the received message and then compares it to the received checksum. If it matches, then the message is valid as far as the checksum can tell.</p>
<p>The first method can produce 64 checksum values. The second method can produce 94 checksum values so should be preferred (unless the user happens to have a Spellman MPS power supply!).</p>
<p>Why not use something like <a href="https://en.wikipedia.org/wiki/Fletcher%27s_checksum">Fletcher's checksum</a> or an <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">8 bit CRC</a> (Cyclic Redundancy Check)? They will produce chars that will be confused with the end char (default is '<br />
'). Why not use a 16 bit method for increased resilience against errors? Oer several years of using the above checksum algorithms in a physics experimental laboratory, they have proved sufficiently robust.</p>
<h4>C++ implementation of the second algorithm</h4>
<div class="fragment"><div class="line">char chksm8bitAllReadableChars(char* rawMessage){</div><div class="line">    uint8_t checksum=0;</div><div class="line">    while(*rawMessage){ // this relies on the char array being NULL terminated!</div><div class="line">        checksum += *rawMessage;</div><div class="line">        rawMessage++;</div><div class="line">    }</div><div class="line">    checksum &amp;= 0x7F; // clear the MSB (0b1111111) so that the number can only be between 0 and 127.</div><div class="line">    checksum += 33; // 33 is the minimum printable char &#39;!&#39;</div><div class="line">    if(checksum &gt; 126){</div><div class="line">        checksum -= 94; // 126 is the last readable char &#39;~&#39;, so wrap back to the first printable char by subtracting 94.</div><div class="line">    }</div><div class="line">    return (char) checksum;</div><div class="line">}</div></div><!-- fragment --><p>A version that works in python could be: </p><div class="fragment"><div class="line">def chksm8bitAllReadableChars(message: str) -&gt; str:</div><div class="line">    checksum = 0</div><div class="line">    for c in message:</div><div class="line">        checksum += ord(c) # convert string char to int</div><div class="line">    checksum &amp;= 127 #0x7F 0b1111111</div><div class="line">    checksum += 33 # first readable char is &#39;!&#39;</div><div class="line">    if(checksum &gt; 126): # last readable char is &#39;~&#39;</div><div class="line">        checksum -= 94</div><div class="line">    return chr(checksum) # convert int back to string char</div></div><!-- fragment --><h3>To do:</h3>
<ol type="1">
<li>Prevent errors in conversion of floats and ints so that they stop conversion if a non numeric char is received.</li>
<li>Add more examples and an example code folder.</li>
<li>Style as real arduino library with command highlighting in the arduino ide.</li>
<li>Submit to arduino library list thingy.</li>
<li>Add option for all printable character checksum. </li>
</ol>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
